<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Block Snake</title>
  <style>
    :root{
      --bg:#0b0f14;
      --ink:#e8eef7;
      --muted:#a9b6c7;
      --grid:rgba(255,255,255,.06);
      --shadow:rgba(0,0,0,.45);
      --accent:#4dd0ff;
    }
    html,body{
      height:100%;
      margin:0;
      background:
        radial-gradient(1200px 700px at 50% 10%, rgba(77,208,255,.10), transparent 55%),
        radial-gradient(900px 500px at 10% 70%, rgba(47,226,141,.08), transparent 60%),
        var(--bg);
      color:var(--ink);
      font-family:system-ui,-apple-system,Segoe UI,Roboto,Helvetica,Arial,"Apple Color Emoji","Segoe UI Emoji";
      overflow:hidden;
    }

    #wrap{
      position:fixed;
      inset:0;
      display:grid;
      grid-template-rows:auto 1fr;
      gap:8px;
      padding:10px;
      box-sizing:border-box;
    }

    /* Top: title left, dial centered */
    #topbar{
      position:relative;
      height:160px; /* reserve space for the dial */
      user-select:none;
    }
    #title{
      position:absolute;
      left:8px;
      top:28px;
      font-weight:1000;
      letter-spacing:1.2px;
      font-size:34px;
      line-height:1;
      text-transform:uppercase;
      background: linear-gradient(90deg, rgba(77,208,255,.95), rgba(232,238,247,.95), rgba(47,226,141,.90));
      -webkit-background-clip:text;
      background-clip:text;
      color:transparent;
      text-shadow:
        0 18px 45px rgba(0,0,0,.45),
        0 0 22px rgba(77,208,255,.18);
    }
    #title:after{
      content:"";
      position:absolute;
      left:0;
      right:auto;
      bottom:-10px;
      width:min(420px, 60vw);
      height:2px;
      border-radius:999px;
      background: linear-gradient(90deg, transparent, rgba(77,208,255,.75), rgba(255,255,255,.55), rgba(47,226,141,.75), transparent);
      opacity:.9;
    }

    #dial{
      position:absolute;
      left:50%;
      top:10px;
      transform:translateX(-50%);
      width:150px;
      height:150px;
      border-radius:999px;
      background:
        radial-gradient(circle at 50% 40%, rgba(255,255,255,.08), transparent 55%),
        radial-gradient(circle at 50% 120%, rgba(77,208,255,.10), transparent 60%),
        rgba(16, 23, 34, .92);
      border:1px solid rgba(255,255,255,.14);
      box-shadow: 0 14px 40px rgba(0,0,0,.55), inset 0 0 0 1px rgba(255,255,255,.05);
      display:grid;
      place-items:center;
    }
    #dial canvas{
      width:140px;
      height:140px;
      display:block;
      background:transparent;
    }

    /* Arena fills space */
    #arena{
      position:relative;
      display:grid;
      place-items:center;
      min-height:0;
    }
    #game{
      width:min(1220px, calc(100vw - 18px));
      height: calc(100vh - 200px);
      max-height: 920px;
      min-height: 420px;
      background: linear-gradient(180deg, rgba(255,255,255,.02), rgba(255,255,255,.01));
      border:1px solid rgba(255,255,255,.10);
      border-radius:22px;
      box-shadow:0 18px 55px var(--shadow);
    }

    /* Stats overlay: no bar */
    #statsOverlay{
      position:absolute;
      left:18px;
      bottom:18px;
      display:grid;
      gap:6px;
      color:rgba(232,238,247,.90);
      font-size:14px;
      font-weight:700;
      user-select:none;
      text-shadow: 0 10px 30px rgba(0,0,0,.65);
      pointer-events:none;
    }
    #statsOverlay span{
      color:rgba(169,182,199,.95);
      font-weight:750;
      margin-right:6px;
    }
    #statsOverlay b{ color:rgba(232,238,247,.95); font-weight:950; }

    /* Splash overlay */
    .overlay{
      position:absolute;
      inset:0;
      display:grid;
      place-items:center;
      background:rgba(0,0,0,.55);
      backdrop-filter: blur(5px);
      opacity:0;
      pointer-events:none;
      transition:opacity .18s ease;
    }
    .overlay.show{ opacity:1; pointer-events:auto; }

    .card{
      position:relative;
      width:min(580px, calc(100vw - 40px));
      border-radius:20px;
      background:rgba(16,23,34,.92);
      border:1px solid rgba(255,255,255,.14);
      box-shadow:0 25px 70px rgba(0,0,0,.6);
      padding:18px 18px 16px;
    }
    .card h2{
      margin:0 0 10px;
      font-size:22px;
      font-weight:900;
      letter-spacing:.2px;
    }
    .subtitle{
      margin:0 0 14px;
      color:var(--muted);
      line-height:1.35;
    }
    .kbd{
      display:inline-flex;
      align-items:center;
      gap:6px;
      padding:7px 10px;
      border-radius:12px;
      background:rgba(255,255,255,.06);
      border:1px solid rgba(255,255,255,.12);
      color:var(--ink);
      font-weight:850;
      font-size:13px;
      white-space:nowrap;
    }

    /* Rank pinned top-right inside splash */
    #rankPinned{
      position:absolute;
      top:14px;
      right:14px;
      padding:8px 10px;
      border-radius:14px;
      background:rgba(255,255,255,.06);
      border:1px solid rgba(255,255,255,.12);
      color:rgba(232,238,247,.95);
      font-weight:950;
      letter-spacing:.2px;
      display:none;
      box-shadow:0 14px 36px rgba(0,0,0,.35);
    }

    .stack{
      display:flex;
      flex-direction:column;
      gap:10px;
      margin-top:12px;
    }
    .pill{
      display:inline-flex;
      align-items:center;
      justify-content:space-between;
      gap:10px;
      padding:10px 12px;
      border-radius:14px;
      background:rgba(255,255,255,.05);
      border:1px solid rgba(255,255,255,.10);
      color:var(--muted);
      font-size:14px;
    }
    select{
      background:rgba(0,0,0,.2);
      border:1px solid rgba(255,255,255,.14);
      color:var(--ink);
      border-radius:12px;
      padding:8px 10px;
      font-weight:750;
      cursor:pointer;
      outline:none;
      min-width:170px;
    }
    option{ background:#0b0f14; }

    .toggle{
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap:12px;
      padding:10px 12px;
      border-radius:14px;
      background:rgba(255,255,255,.05);
      border:1px solid rgba(255,255,255,.10);
      color:var(--muted);
      font-size:14px;
      user-select:none;
    }
    .toggleBtn{
      border:none;
      cursor:pointer;
      font-weight:900;
      padding:8px 10px;
      border-radius:12px;
      background:rgba(77,208,255,.14);
      border:1px solid rgba(77,208,255,.35);
      color:rgba(232,238,247,.98);
    }
    .toggleBtn.off{
      background:rgba(255,255,255,.06);
      border:1px solid rgba(255,255,255,.12);
      color:rgba(232,238,247,.85);
    }

    .grid2{
      display:grid;
      grid-template-columns:1fr 1fr;
      gap:10px 14px;
      margin:12px 0 0;
      color:var(--muted);
      font-size:14px;
    }
    .grid2 b{ color:var(--ink); }
  </style>
</head>
<body>
  <div id="wrap">
    <div id="topbar">
      <div id="title">Block Snake</div>
      <div id="dial" aria-label="target angle">
        <canvas id="dialCanvas"></canvas>
      </div>
    </div>

    <div id="arena">
      <canvas id="game"></canvas>

      <div id="statsOverlay">
        <div><span>Time:</span> <b id="timeText">0:00</b></div>
        <div><span>Length:</span> <b id="lenText">0</b></div>
        <div><span>Speed:</span> <b id="speedText">—</b></div>
      </div>

      <div id="splash" class="overlay show">
        <div class="card">
          <div id="rankPinned">Rank 1: GOAT</div>

          <h2 id="splashTitle">Angle Snake</h2>
          <p class="subtitle" id="splashText">
            Eat the food that matches the target angle in the circle (top-center).
            Correct = grow, wrong = shrink (but never below the start size).
          </p>

          <div class="subtitle" style="margin-bottom:10px;">
            Controls: <span class="kbd">Arrow Keys</span> or <span class="kbd">WASD</span>
          </div>

          <div class="stack">
            <div class="pill">
              <span>Grade</span>
              <select id="gradeSelect" aria-label="grade">
                <option value="5" selected>Grade 5</option>
                <option value="6">Grade 6</option>
              </select>
            </div>

            <div class="pill">
              <span>Colour</span>
              <select id="colorSelect" aria-label="snake colour">
                <option value="rainbow" selected>Rainbow</option>
                <option value="red">Red</option>
                <option value="orange">Orange</option>
                <option value="yellow">Yellow</option>
                <option value="green">Green</option>
                <option value="blue">Blue</option>
                <option value="indigo">Indigo</option>
                <option value="violet">Violet</option>
                <option value="white">White</option>
              </select>
            </div>

            <div class="toggle">
              <span>Angle Number</span>
              <button id="angleNumBtn" class="toggleBtn off" type="button">Off</button>
            </div>
          </div>

          <div class="subtitle" style="margin:14px 0 0;">
            <b id="enterPrompt">Press Enter to start.</b>
          </div>

          <div id="postGame" style="display:none;">
            <div class="grid2">
              <div>Time: <b id="finalTime">—</b></div>
              <div>Length: <b id="finalLen">—</b></div>
              <div>Score: <b id="finalScore">—</b></div>
              <div>Accuracy: <b id="finalAcc">—</b></div>
            </div>
          </div>
        </div>
      </div>
    </div>
  </div>

  <script>
    (() => {
      // ---------- Elements ----------
      const canvas = document.getElementById('game');
      const ctx = canvas.getContext('2d');

      const dialCanvas = document.getElementById('dialCanvas');
      const dctx = dialCanvas.getContext('2d');

      const splash = document.getElementById('splash');
      const splashTitle = document.getElementById('splashTitle');
      const splashText = document.getElementById('splashText');
      const enterPrompt = document.getElementById('enterPrompt');
      const postGame = document.getElementById('postGame');

      const rankPinned = document.getElementById('rankPinned');
      const finalTime = document.getElementById('finalTime');
      const finalLen  = document.getElementById('finalLen');
      const finalScore= document.getElementById('finalScore');
      const finalAcc  = document.getElementById('finalAcc');

      const timeText  = document.getElementById('timeText');
      const lenText   = document.getElementById('lenText');
      const speedText = document.getElementById('speedText');

      const gradeSelect = document.getElementById('gradeSelect');
      const colorSelect = document.getElementById('colorSelect');
      const angleNumBtn = document.getElementById('angleNumBtn');

      // ---------- Settings ----------
      const START_LEN = 5;
      const MIN_LEN = START_LEN;
      const DESIRED_CELL = 36;

      const START_SPEED = 8;
      const SPEED_EVERY = 20;
      const SPEED_STEP  = 1;
      const SPEED_CAP   = 18;

      const G5 = [45, 90, 135, 180];
      const G6 = [45, 90, 135, 180, 225, 270, 315, 360];

      // ---------- State ----------
      let grid = { cols:0, rows:0, cell:DESIRED_CELL, offsetX:0, offsetY:0, w:0, h:0 };

      let onSplash = true;
      let running = false;
      let dead = false;

      let gradePending = 5;
      let gradeActive = 5;

      let showAngleNumber = false; // default OFF
      let targetAngle = 90;
      let prevTargetAngle = null;

      let snake = [];
      let dir = {x:1,y:0};
      let nextDir = {x:1,y:0};

      let foods = [];
      let correctCount = 0;
      let wrongCount = 0;

      let startTimeMs = 0;
      let elapsedMs = 0;

      let speed = START_SPEED;
      let stepIntervalMs = 1000 / speed;
      let lastStepMs = 0;
      let lastRampBucket = 0;

      // ---------- Helpers ----------
      const clamp = (n,a,b)=>Math.max(a,Math.min(b,n));
      const randInt = (min,max)=>Math.floor(Math.random()*(max-min))+min;

      function formatTime(ms){
        const s = Math.floor(ms/1000);
        const m = Math.floor(s/60);
        const r = s%60;
        return `${m}:${String(r).padStart(2,'0')}`;
      }

      function resizeCanvases(){
        const rect = canvas.getBoundingClientRect();
        canvas.width  = Math.floor(rect.width * devicePixelRatio);
        canvas.height = Math.floor(rect.height * devicePixelRatio);
        ctx.setTransform(devicePixelRatio,0,0,devicePixelRatio,0,0);

        const drect = dialCanvas.getBoundingClientRect();
        dialCanvas.width  = Math.floor(drect.width * devicePixelRatio);
        dialCanvas.height = Math.floor(drect.height * devicePixelRatio);
        dctx.setTransform(devicePixelRatio,0,0,devicePixelRatio,0,0);
      }

      function recomputeGrid(){
        const rect = canvas.getBoundingClientRect();
        const cols = Math.floor(rect.width / DESIRED_CELL);
        const rows = Math.floor(rect.height / DESIRED_CELL);

        grid.cols = Math.max(12, cols);
        grid.rows = Math.max(9, rows);

        grid.cell = Math.floor(Math.min(rect.width / grid.cols, rect.height / grid.rows));
        grid.w = grid.cols * grid.cell;
        grid.h = grid.rows * grid.cell;
        grid.offsetX = Math.floor((rect.width - grid.w) / 2);
        grid.offsetY = Math.floor((rect.height - grid.h) / 2);
      }

      function isOccupied(x,y){
        for (const s of snake) if (s.x===x && s.y===y) return true;
        for (const f of foods) if (f.x===x && f.y===y) return true;
        return false;
      }

      function updateHud(){
        timeText.textContent = formatTime(elapsedMs);
        lenText.textContent = String(snake.length);
        speedText.textContent = `${speed.toFixed(0)} /s`;
      }

      // ---------- Game setup ----------
      function resetSnake(){
        snake = [];
        const startX = Math.floor(grid.cols/2);
        const startY = Math.floor(grid.rows/2);
        for (let i=0;i<START_LEN;i++) snake.push({x:startX-i, y:startY});
        dir = {x:1,y:0};
        nextDir = {x:1,y:0};
      }

      function pickTargetAngle(){
        const pool = (gradeActive===6) ? G6 : G5;
        let picked = pool[randInt(0, pool.length)];
        let tries = 0;
        while (picked === prevTargetAngle && tries < 30){
          picked = pool[randInt(0, pool.length)];
          tries++;
        }
        prevTargetAngle = picked;
        return picked;
      }

      function placeFood(value,isCorrect){
        let x,y,tries=0;
        do{
          x = randInt(0, grid.cols);
          y = randInt(0, grid.rows);
          tries++;
          if (tries > 500) break;
        } while (isOccupied(x,y));
        foods.push({x,y,value,isCorrect});
      }

      function spawnFoodsAndTarget(){
        foods = [];
        targetAngle = pickTargetAngle();

        const pool = (gradeActive===6) ? G6 : G5;
        let wrong = pool[randInt(0, pool.length)];
        let tries = 0;
        while (wrong === targetAngle && tries < 40){
          wrong = pool[randInt(0, pool.length)];
          tries++;
        }

        placeFood(targetAngle, true);
        placeFood(wrong, false);

        drawDial();
      }

      function resetRunState(){
        correctCount = 0;
        wrongCount = 0;

        speed = START_SPEED;
        stepIntervalMs = 1000 / speed;
        lastRampBucket = 0;

        resetSnake();
        spawnFoodsAndTarget();

        elapsedMs = 0;
        updateHud();
        draw();
      }

      // ---------- Splash ----------
      function showSplash(mode){
        onSplash = true;
        splash.classList.add('show');

        if (mode === "start"){
          dead = false;
          postGame.style.display = "none";
          rankPinned.style.display = "none";
          splashTitle.textContent = "Angle Snake";
          splashText.textContent =
            "Eat the food that matches the target angle in the circle (top-center). Correct = grow, wrong = shrink (but never below the start size).";
          enterPrompt.textContent = "Press Enter to start.";
        } else {
          rankPinned.style.display = "block";
          postGame.style.display = "block";
          splashTitle.textContent = "Game Over";
          splashText.textContent = "Press Enter to retry.";
          enterPrompt.textContent = "Press Enter to retry.";
        }
      }

      function hideSplash(){
        onSplash = false;
        splash.classList.remove('show');
      }

      // ---------- Start / End ----------
      function startGame(){
        gradeActive = gradePending;

        running = true;
        dead = false;

        resetRunState();
        startTimeMs = performance.now();
        lastStepMs = performance.now();
        hideSplash();
      }

      function endGame(){
        running = false;
        dead = true;

        const timeSec = Math.floor(elapsedMs/1000);
        const len = snake.length;

        const base = (timeSec * 10) + (len * 50) + (correctCount * 200);
        const penaltyMultiplier = Math.max(0.30, 1 - (wrongCount * 0.05));
        const score = Math.max(0, Math.floor(base * penaltyMultiplier));

        const total = correctCount + wrongCount;
        const acc = total===0 ? 0 : Math.round((correctCount/total)*100);

        finalTime.textContent = formatTime(elapsedMs);
        finalLen.textContent = String(len);
        finalScore.textContent = String(score);
        finalAcc.textContent = `${acc}%`;

        const {rankName, rankIndex} = getRank(score);
        rankPinned.textContent = `Rank ${rankIndex}: ${rankName}`;

        showSplash("retry");
      }

      function getRank(score){
        const tiers = [
          { name:"GOAT",     min:13000 },
          { name:"Legend",   min:10800 },
          { name:"Elite",    min: 8800 },
          { name:"Champion", min: 7000 },
          { name:"Pro",      min: 5400 },
          { name:"Skilled",  min: 4000 },
          { name:"Contender",min: 2800 },
          { name:"Apprentice",min:1800 },
          { name:"Rookie",   min:  900 },
          { name:"Noob",     min:    0 },
        ];
        for (let i=0;i<tiers.length;i++){
          if (score >= tiers[i].min) return { rankName: tiers[i].name, rankIndex: i+1 };
        }
        return { rankName:"Noob", rankIndex:10 };
      }

      // ---------- Input ----------
      const keyMap = {
        ArrowUp:{x:0,y:-1}, ArrowDown:{x:0,y:1}, ArrowLeft:{x:-1,y:0}, ArrowRight:{x:1,y:0},
        w:{x:0,y:-1}, s:{x:0,y:1}, a:{x:-1,y:0}, d:{x:1,y:0},
        W:{x:0,y:-1}, S:{x:0,y:1}, A:{x:-1,y:0}, D:{x:1,y:0},
      };

      function trySetDir(v){
        if (v.x === -dir.x && v.y === -dir.y) return;
        nextDir = {x:v.x, y:v.y};
      }

      window.addEventListener('keydown', (e) => {
        if (onSplash && e.key === "Enter"){
          e.preventDefault();
          e.stopPropagation();
          if (document.activeElement && document.activeElement.tagName === "SELECT"){
            document.activeElement.blur();
          }
          startGame();
          return;
        }

        if (onSplash){
          const v = keyMap[e.key];
          if (v) trySetDir(v);
          return;
        }

        const v = keyMap[e.key];
        if (v){
          e.preventDefault();
          trySetDir(v);
        }
      }, {passive:false});

      gradeSelect.addEventListener('change', () => {
        gradePending = (Number(gradeSelect.value) === 6) ? 6 : 5;
      });

      angleNumBtn.addEventListener('click', () => {
        showAngleNumber = !showAngleNumber;
        angleNumBtn.textContent = showAngleNumber ? "On" : "Off";
        angleNumBtn.classList.toggle('off', !showAngleNumber);
        drawDial();
      });

      // ---------- Mechanics ----------
      function rampSpeedIfNeeded(){
        const sec = Math.floor(elapsedMs/1000);
        const bucket = Math.floor(sec / SPEED_EVERY);
        if (bucket > lastRampBucket){
          lastRampBucket = bucket;
          speed = clamp(speed + SPEED_STEP, START_SPEED, SPEED_CAP);
          stepIntervalMs = 1000 / speed;
        }
      }

      function step(){
        dir = {...nextDir};

        const head = snake[0];
        const nx = head.x + dir.x;
        const ny = head.y + dir.y;

        if (nx < 0 || nx >= grid.cols || ny < 0 || ny >= grid.rows){
          endGame(); return;
        }

        for (let i=0;i<snake.length;i++){
          if (snake[i].x===nx && snake[i].y===ny){
            endGame(); return;
          }
        }

        snake.unshift({x:nx,y:ny});

        let ate = null;
        for (const f of foods){
          if (f.x===nx && f.y===ny){ ate = f; break; }
        }

        if (ate){
          if (ate.isCorrect){
            correctCount++;
          } else {
            wrongCount++;
            if (snake.length>0) snake.pop();
            if (snake.length > MIN_LEN) snake.pop();
            while (snake.length < MIN_LEN){
              const t = snake[snake.length-1];
              snake.push({x:t.x, y:t.y});
            }
          }
          spawnFoodsAndTarget();
        } else {
          snake.pop();
        }
      }

      // ---------- Drawing ----------
      function roundRect(c,x,y,w,h,r){
        const rr = Math.min(r, w/2, h/2);
        c.beginPath();
        c.moveTo(x+rr,y);
        c.arcTo(x+w,y,x+w,y+h,rr);
        c.arcTo(x+w,y+h,x,y+h,rr);
        c.arcTo(x,y+h,x,y,rr);
        c.arcTo(x,y,x+w,y,rr);
        c.closePath();
      }

      function snakeColorAt(i){
        const mode = colorSelect.value;
        if (mode === 'rainbow'){
          const t = snake.length<=1 ? 0 : (i/(snake.length-1));
          const hue = (210 + t*280) % 360;
          return `hsl(${hue}, 90%, 62%)`;
        }
        const map = {
          red:'hsl(0, 90%, 62%)',
          orange:'hsl(28, 92%, 60%)',
          yellow:'hsl(55, 92%, 60%)',
          green:'hsl(140, 70%, 55%)',
          blue:'hsl(205, 95%, 62%)',
          indigo:'hsl(255, 80%, 65%)',
          violet:'hsl(285, 85%, 68%)',
          white:'hsl(0, 0%, 92%)',
        };
        return map[mode] || 'hsl(205, 95%, 62%)';
      }

      function drawGrid(){
        ctx.save();
        ctx.translate(grid.offsetX, grid.offsetY);
        ctx.strokeStyle = getComputedStyle(document.documentElement).getPropertyValue('--grid').trim() || 'rgba(255,255,255,.06)';
        ctx.lineWidth = 1;

        for (let c=0;c<=grid.cols;c++){
          const x = c*grid.cell + 0.5;
          ctx.beginPath(); ctx.moveTo(x,0); ctx.lineTo(x,grid.h); ctx.stroke();
        }
        for (let r=0;r<=grid.rows;r++){
          const y = r*grid.cell + 0.5;
          ctx.beginPath(); ctx.moveTo(0,y); ctx.lineTo(grid.w,y); ctx.stroke();
        }
        ctx.restore();
      }

      function drawFoods(){
        ctx.save();
        ctx.translate(grid.offsetX, grid.offsetY);

        for (const f of foods){
          const x = f.x * grid.cell;
          const y = f.y * grid.cell;

          ctx.fillStyle = f.isCorrect ? 'rgba(47,226,141,.18)' : 'rgba(255,93,108,.18)';
          ctx.strokeStyle = f.isCorrect ? 'rgba(47,226,141,.75)' : 'rgba(255,93,108,.75)';
          ctx.lineWidth = 2;

          const pad = 3;
          roundRect(ctx, x+pad, y+pad, grid.cell-pad*2, grid.cell-pad*2, 10);
          ctx.fill(); ctx.stroke();

          ctx.fillStyle = 'rgba(255,255,255,.92)';
          ctx.font = '900 16px system-ui, -apple-system, Segoe UI, Roboto, Arial';
          ctx.textAlign = 'center';
          ctx.textBaseline = 'middle';
          ctx.fillText(String(f.value), x + grid.cell/2, y + grid.cell/2 + 0.5);
        }

        ctx.restore();
      }

      function drawSnake(){
        ctx.save();
        ctx.translate(grid.offsetX, grid.offsetY);

        const pad = 3;
        const r = 12;

        for (let i=snake.length-1;i>=0;i--){
          const s = snake[i];
          const x = s.x * grid.cell;
          const y = s.y * grid.cell;

          ctx.fillStyle = snakeColorAt(i);
          if (i===0){
            ctx.shadowColor = ctx.fillStyle;
            ctx.shadowBlur = 16;
          } else {
            ctx.shadowBlur = 0;
          }

          roundRect(ctx, x+pad, y+pad, grid.cell-pad*2, grid.cell-pad*2, r);
          ctx.fill();

          if (i===0){
            ctx.shadowBlur = 0;
            ctx.fillStyle = 'rgba(0,0,0,.35)';
            const cx = x + grid.cell/2;
            const cy = y + grid.cell/2;
            const ex = dir.x===1 ? 5 : dir.x===-1 ? -5 : 0;
            const ey = dir.y===1 ? 5 : dir.y===-1 ? -5 : 0;
            ctx.beginPath(); ctx.arc(cx-5+ex, cy-4+ey, 2.2, 0, Math.PI*2); ctx.fill();
            ctx.beginPath(); ctx.arc(cx+5+ex, cy-4+ey, 2.2, 0, Math.PI*2); ctx.fill();
          }
        }

        ctx.restore();
      }

      function draw(){
        const rect = canvas.getBoundingClientRect();
        ctx.clearRect(0,0,rect.width,rect.height);

        ctx.save();
        ctx.fillStyle = 'rgba(0,0,0,.10)';
        ctx.fillRect(0,0,rect.width,rect.height);
        ctx.restore();

        drawGrid();
        drawFoods();
        drawSnake();
      }

      function drawDial(){
        const rect = dialCanvas.getBoundingClientRect();
        const w = rect.width, h = rect.height;
        const cx = w/2, cy = h/2;
        const R = Math.min(w,h)*0.42;

        dctx.clearRect(0,0,w,h);

        dctx.save();
        dctx.lineWidth = 4;
        dctx.strokeStyle = 'rgba(255,255,255,.10)';
        dctx.beginPath();
        dctx.arc(cx,cy,R*1.06,0,Math.PI*2);
        dctx.stroke();

        const rad = (targetAngle % 360) * Math.PI/180;
        const theta = -rad;

        dctx.lineWidth = 5;
        dctx.strokeStyle = 'rgba(232,238,247,.92)';
        dctx.beginPath();
        dctx.moveTo(cx,cy);
        dctx.lineTo(cx + R, cy);
        dctx.stroke();

        dctx.strokeStyle = 'rgba(77,208,255,.95)';
        dctx.beginPath();
        dctx.moveTo(cx,cy);
        dctx.lineTo(cx + Math.cos(theta)*R, cy + Math.sin(theta)*R);
        dctx.stroke();

        const arcR = R*0.62;
        dctx.lineWidth = 7;
        dctx.strokeStyle = 'rgba(255,255,255,.82)';
        dctx.lineCap = 'round';

        if (targetAngle === 360){
          dctx.beginPath();
          dctx.arc(cx,cy,arcR,0,Math.PI*2);
          dctx.stroke();
        } else {
          dctx.beginPath();
          dctx.arc(cx,cy,arcR,0,theta,theta<0);
          dctx.stroke();
        }

        if (showAngleNumber){
          dctx.fillStyle = 'rgba(232,238,247,.95)';
          dctx.font = '950 22px system-ui, -apple-system, Segoe UI, Roboto, Arial';
          dctx.textAlign = 'center';
          dctx.textBaseline = 'middle';
          dctx.fillText(`${targetAngle}°`, cx, cy + R*0.83);
        }

        dctx.restore();
      }

      // ---------- Main loop ----------
      function tick(now){
        if (running && !dead){
          elapsedMs = now - startTimeMs;
          rampSpeedIfNeeded();

          if (now - lastStepMs >= stepIntervalMs){
            lastStepMs = now;
            step();
          }
          updateHud();
        }
        draw();
        requestAnimationFrame(tick);
      }

      // ---------- Init ----------
      function init(){
        // UI defaults
        showAngleNumber = false;
        angleNumBtn.textContent = "Off";
        angleNumBtn.classList.add('off');

        gradePending = (Number(gradeSelect.value) === 6) ? 6 : 5;

        resizeCanvases();
        recomputeGrid();

        // visible dial on splash
        gradeActive = gradePending;
        resetSnake();
        spawnFoodsAndTarget();
        updateHud();
        draw();

        showSplash("start");

        window.addEventListener('resize', () => {
          resizeCanvases();
          recomputeGrid();
          draw();
          drawDial();
        });

        requestAnimationFrame(tick);
      }

      init();
    })();
  </script>
</body>
</html>

