<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Block Snake</title>
  <style>
    :root{
      --bg:#0b0f14;
      --ink:#e8eef7;
      --muted:#a9b6c7;
      --grid:rgba(255,255,255,.06);
      --shadow:rgba(0,0,0,.45);
    }
    html,body{
      height:100%;
      margin:0;
      background:
        radial-gradient(1200px 700px at 50% 10%, rgba(77,208,255,.10), transparent 55%),
        radial-gradient(900px 500px at 10% 70%, rgba(47,226,141,.08), transparent 60%),
        var(--bg);
      color:var(--ink);
      font-family:system-ui,-apple-system,Segoe UI,Roboto,Helvetica,Arial,"Apple Color Emoji","Segoe UI Emoji";
      overflow:hidden;
    }

    #wrap{
      position:fixed;
      inset:0;
      display:grid;
      grid-template-rows:auto 1fr;
      gap:8px;
      padding:10px;
      box-sizing:border-box;
    }

    /* Top: title left, dial centered */
    #topbar{
      position:relative;
      height:160px;
      user-select:none;
    }
    #title{
      position:absolute;
      left:8px;
      top:28px;
      font-weight:1000;
      letter-spacing:1.2px;
      font-size:34px;
      line-height:1;
      text-transform:uppercase;
      background: linear-gradient(90deg, rgba(77,208,255,.95), rgba(232,238,247,.95), rgba(47,226,141,.90));
      -webkit-background-clip:text;
      background-clip:text;
      color:transparent;
      text-shadow:
        0 18px 45px rgba(0,0,0,.45),
        0 0 22px rgba(77,208,255,.18);
    }
    #title:after{
      content:"";
      position:absolute;
      left:0;
      bottom:-10px;
      width:min(420px, 60vw);
      height:2px;
      border-radius:999px;
      background: linear-gradient(90deg, transparent, rgba(77,208,255,.75), rgba(255,255,255,.55), rgba(47,226,141,.75), transparent);
      opacity:.9;
    }

    #dial{
      position:absolute;
      left:50%;
      top:10px;
      transform:translateX(-50%);
      width:150px;
      height:150px;
      border-radius:999px;
      background:
        radial-gradient(circle at 50% 40%, rgba(255,255,255,.08), transparent 55%),
        radial-gradient(circle at 50% 120%, rgba(77,208,255,.10), transparent 60%),
        rgba(16, 23, 34, .92);
      border:1px solid rgba(255,255,255,.14);
      box-shadow: 0 14px 40px rgba(0,0,0,.55), inset 0 0 0 1px rgba(255,255,255,.05);
      display:grid;
      place-items:center;
    }
    #dial canvas{
      width:140px;
      height:140px;
      display:block;
      background:transparent;
    }

    /* Arena */
    #arena{
      position:relative;
      display:grid;
      place-items:center;
      min-height:0;
    }
    #game{
      width:min(1220px, calc(100vw - 18px));
      height:clamp(640px, calc(100vh - 200px), 920px);
      background: linear-gradient(180deg, rgba(255,255,255,.02), rgba(255,255,255,.01));
      border:1px solid rgba(255,255,255,.10);
      border-radius:22px;
      box-shadow:0 18px 55px var(--shadow);
    }

    /* Stats overlay */
    #statsOverlay{
      position:absolute;
      left:18px;
      bottom:18px;
      display:grid;
      gap:6px;
      color:rgba(232,238,247,.90);
      font-size:14px;
      font-weight:700;
      user-select:none;
      text-shadow: 0 10px 30px rgba(0,0,0,.65);
      pointer-events:none;
    }
    #statsOverlay span{
      color:rgba(169,182,199,.95);
      font-weight:750;
      margin-right:6px;
    }
    #statsOverlay b{ color:rgba(232,238,247,.95); font-weight:950; }

    /* Splash overlay */
    .overlay{
      position:absolute;
      inset:0;
      display:grid;
      place-items:center;
      background:rgba(0,0,0,.55);
      backdrop-filter: blur(5px);
      opacity:0;
      pointer-events:none;
      transition:opacity .18s ease;
    }
    .overlay.show{ opacity:1; pointer-events:auto; }

    .card{
      position:relative;
      width:min(600px, calc(100vw - 40px));
      border-radius:20px;
      background:rgba(16,23,34,.92);
      border:1px solid rgba(255,255,255,.14);
      box-shadow:0 25px 70px rgba(0,0,0,.6);
      padding:18px 18px 16px;
    }
    .card h2{
      margin:0 0 10px;
      font-size:22px;
      font-weight:900;
      letter-spacing:.2px;
    }
    .subtitle{
      margin:0 0 14px;
      color:var(--muted);
      line-height:1.35;
    }
    .kbd{
      display:inline-flex;
      align-items:center;
      gap:6px;
      padding:7px 10px;
      border-radius:12px;
      background:rgba(255,255,255,.06);
      border:1px solid rgba(255,255,255,.12);
      color:var(--ink);
      font-weight:850;
      font-size:13px;
      white-space:nowrap;
    }

    /* Rank pinned top-right inside splash */
    #rankPinned{
      position:absolute;
      top:14px;
      right:14px;
      padding:8px 10px;
      border-radius:14px;
      background:rgba(255,255,255,.06);
      border:1px solid rgba(255,255,255,.12);
      color:rgba(232,238,247,.95);
      font-weight:950;
      letter-spacing:.2px;
      display:none;
      box-shadow:0 14px 36px rgba(0,0,0,.35);
    }

    .stack{
      display:flex;
      flex-direction:column;
      gap:10px;
      margin-top:12px;
    }
    .pill{
      display:inline-flex;
      align-items:center;
      justify-content:space-between;
      gap:10px;
      padding:10px 12px;
      border-radius:14px;
      background:rgba(255,255,255,.05);
      border:1px solid rgba(255,255,255,.10);
      color:var(--muted);
      font-size:14px;
    }
    select{
      background:rgba(0,0,0,.2);
      border:1px solid rgba(255,255,255,.14);
      color:var(--ink);
      border-radius:12px;
      padding:8px 10px;
      font-weight:750;
      cursor:pointer;
      outline:none;
      min-width:190px;
    }
    option{ background:#0b0f14; }

    .toggle{
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap:12px;
      padding:10px 12px;
      border-radius:14px;
      background:rgba(255,255,255,.05);
      border:1px solid rgba(255,255,255,.10);
      color:var(--muted);
      font-size:14px;
      user-select:none;
    }
    .toggleBtn{
      border:none;
      cursor:pointer;
      font-weight:900;
      padding:8px 10px;
      border-radius:12px;
      background:rgba(77,208,255,.14);
      border:1px solid rgba(77,208,255,.35);
      color:rgba(232,238,247,.98);
    }
    .toggleBtn.off{
      background:rgba(255,255,255,.06);
      border:1px solid rgba(255,255,255,.12);
      color:rgba(232,238,247,.85);
    }

    .grid2{
      display:grid;
      grid-template-columns:1fr 1fr;
      gap:10px 14px;
      margin:12px 0 0;
      color:var(--muted);
      font-size:14px;
    }
    .grid2 b{ color:var(--ink); }
  </style>
</head>
<body>
  <div id="wrap">
    <div id="topbar">
      <div id="title">Block Snake</div>
      <div id="dial" aria-label="target angle">
        <canvas id="dialCanvas"></canvas>
      </div>
    </div>

    <div id="arena">
      <canvas id="game"></canvas>

      <div id="statsOverlay">
        <div><span>Time:</span> <b id="timeText">0:00</b></div>
        <div><span>Length:</span> <b id="lenText">0</b></div>
        <div><span>Speed:</span> <b id="speedText">—</b></div>
      </div>

      <div id="splash" class="overlay show">
        <div class="card">
          <div id="rankPinned">Rank 1: GOAT</div>

          <h2 id="splashTitle">Angle Snake</h2>
          <p class="subtitle" id="splashText">
            Eat the food that matches the target angle in the circle (top-center).
            Correct = grow, wrong = shrink (but never below the start size).
          </p>

          <div class="subtitle" style="margin-bottom:10px;">
            Controls: <span class="kbd">Arrow Keys</span> or <span class="kbd">WASD</span>
          </div>

          <div class="stack">
            <div class="pill">
              <span>Grade</span>
              <select id="gradeSelect" aria-label="grade">
                <option value="5" selected>Grade 5</option>
                <option value="6">Grade 6</option>
              </select>
            </div>

            <div class="pill">
              <span>Arena Size</span>
              <select id="arenaSelect" aria-label="arena size">
                <option value="large" selected>Large (Default)</option>
                <option value="medium">Medium</option>
                <option value="small">Small</option>
              </select>
            </div>

            <div class="pill">
              <span>Speed</span>
              <select id="speedSelect" aria-label="speed">
                <option value="easy">Easy</option>
                <option value="normal" selected>Normal (Default)</option>
                <option value="hard">Hard</option>
              </select>
            </div>

            <div class="pill">
              <span>Colour</span>
              <select id="colorSelect" aria-label="snake colour">
                <option value="rainbow" selected>Rainbow</option>
                <option value="red">Red</option>
                <option value="orange">Orange</option>
                <option value="yellow">Yellow</option>
                <option value="green">Green</option>
                <option value="blue">Blue</option>
                <option value="indigo">Indigo</option>
                <option value="violet">Violet</option>
                <option value="white">White</option>
              </select>
            </div>

            <div class="toggle">
              <span>Angle Number</span>
              <button id="angleNumBtn" class="toggleBtn off" type="button">Off</button>
            </div>
          </div>

          <div class="subtitle" style="margin:14px 0 0;">
            <b id="enterPrompt">Press Enter to start.</b>
          </div>

          <div id="postGame" style="display:none;">
            <div class="grid2">
              <div>Time: <b id="finalTime">—</b></div>
              <div>Length: <b id="finalLen">—</b></div>
              <div>Score: <b id="finalScore">—</b></div>
              <div>Accuracy: <b id="finalAcc">—</b></div>
            </div>
          </div>
        </div>
      </div>
    </div>
  </div>

  <script>
    (() => {
      // ---------- Elements ----------
      const canvas = document.getElementById('game');
      const ctx = canvas.getContext('2d');

      const dialCanvas = document.getElementById('dialCanvas');
      const dctx = dialCanvas.getContext('2d');

      const splash = document.getElementById('splash');
      const splashTitle = document.getElementById('splashTitle');
      const splashText = document.getElementById('splashText');
      const enterPrompt = document.getElementById('enterPrompt');
      const postGame = document.getElementById('postGame');

      const rankPinned = document.getElementById('rankPinned');
      const finalTime = document.getElementById('finalTime');
      const finalLen  = document.getElementById('finalLen');
      const finalScore= document.getElementById('finalScore');
      const finalAcc  = document.getElementById('finalAcc');

      const timeText  = document.getElementById('timeText');
      const lenText   = document.getElementById('lenText');
      const speedText = document.getElementById('speedText');

      const gradeSelect = document.getElementById('gradeSelect');
      const arenaSelect = document.getElementById('arenaSelect');
      const speedSelect = document.getElementById('speedSelect');
      const colorSelect = document.getElementById('colorSelect');
      const angleNumBtn = document.getElementById('angleNumBtn');

      // ---------- Content pools ----------
      const G5 = [45, 90, 135, 180];
      const G6 = [45, 90, 135, 180, 225, 270, 315, 360];

      // ---------- Speed profiles ----------
      const SPEED_PROFILES = {
        easy:   { start: 6,  cap: 14, every: 22, step: 1 },
        normal: { start: 8,  cap: 18, every: 20, step: 1 },
        hard:   { start: 11, cap: 22, every: 18, step: 1 },
      };

      // ---------- Game settings ----------
      const START_LEN = 5;
      const MIN_LEN = START_LEN;

      // For LARGE arena we keep your old dynamic feel using this:
      const DESIRED_CELL_LARGE = 36;

      // Medium/small: grid size targets
      const GRID_PRESETS = {
        small: 10,
        medium: 14,
        large: null, // dynamic
      };

      // Foods over time
      function foodCountFromTime(ms){
        // 2 initially, 3 after 60s, 4 after 90s
        let n = 2;
        if (ms >= 60_000) n++;
        if (ms >= 90_000) n++;
        return n;
      }

      // Food color themes (2 colors per refresh)
      const FOOD_THEMES = [
        { aFill:'rgba(47,226,141,.18)', aStroke:'rgba(47,226,141,.80)', bFill:'rgba(255,93,108,.18)', bStroke:'rgba(255,93,108,.80)' },
        { aFill:'rgba(77,208,255,.18)', aStroke:'rgba(77,208,255,.85)', bFill:'rgba(255,196,77,.18)', bStroke:'rgba(255,196,77,.85)' },
        { aFill:'rgba(180,120,255,.18)', aStroke:'rgba(180,120,255,.85)', bFill:'rgba(255,120,200,.18)', bStroke:'rgba(255,120,200,.85)' },
        { aFill:'rgba(120,255,240,.16)', aStroke:'rgba(120,255,240,.85)', bFill:'rgba(255,140,80,.18)', bStroke:'rgba(255,140,80,.85)' },
        { aFill:'rgba(120,170,255,.18)', aStroke:'rgba(120,170,255,.85)', bFill:'rgba(240,120,255,.16)', bStroke:'rgba(240,120,255,.85)' },
      ];

      // ---------- State ----------
      let grid = { cols:0, rows:0, cell:36, offsetX:0, offsetY:0, w:0, h:0 };

      let onSplash = true;
      let running = false;
      let dead = false;

      let gradePending = 5;
      let gradeActive = 5;

      let arenaPending = 'large';
      let arenaActive = 'large';

      let speedPending = 'normal';
      let speedActive = 'normal';

      let showAngleNumber = false; // default OFF

      let targetAngle = 90;
      let prevTargetAngle = null;

      let snake = [];
      let dir = {x:1,y:0};
      let nextDir = {x:1,y:0};

      let foods = []; // {x,y,value,isCorrect, fill, stroke}

      let correctCount = 0;
      let wrongCount = 0;

      let startTimeMs = 0;
      let elapsedMs = 0;

      let speed = SPEED_PROFILES.normal.start;
      let stepIntervalMs = 1000 / speed;
      let lastStepMs = 0;
      let lastRampBucket = 0;

      // current food theme assignment
      let curTheme = FOOD_THEMES[0];
      let correctUsesA = true;

      // ---------- Helpers ----------
      const clamp = (n,a,b)=>Math.max(a,Math.min(b,n));
      const randInt = (min,max)=>Math.floor(Math.random()*(max-min))+min;

      function shuffle(arr){
        for (let i=arr.length-1;i>0;i--){
          const j = Math.floor(Math.random()*(i+1));
          [arr[i],arr[j]] = [arr[j],arr[i]];
        }
        return arr;
      }

      function formatTime(ms){
        const s = Math.floor(ms/1000);
        const m = Math.floor(s/60);
        const r = s%60;
        return `${m}:${String(r).padStart(2,'0')}`;
      }

      function resizeCanvases(){
        const rect = canvas.getBoundingClientRect();
        canvas.width  = Math.floor(rect.width * devicePixelRatio);
        canvas.height = Math.floor(rect.height * devicePixelRatio);
        ctx.setTransform(devicePixelRatio,0,0,devicePixelRatio,0,0);

        const drect = dialCanvas.getBoundingClientRect();
        dialCanvas.width  = Math.floor(drect.width * devicePixelRatio);
        dialCanvas.height = Math.floor(drect.height * devicePixelRatio);
        dctx.setTransform(devicePixelRatio,0,0,devicePixelRatio,0,0);
      }

      function recomputeGrid(){
        const rect = canvas.getBoundingClientRect();
        const preset = GRID_PRESETS[arenaActive];

        let cols, rows;

        if (preset == null){
          // Large: dynamic based on desired cell size (old feel)
          cols = Math.floor(rect.width / DESIRED_CELL_LARGE);
          rows = Math.floor(rect.height / DESIRED_CELL_LARGE);
          cols = Math.max(12, cols);
          rows = Math.max(9, rows);
        } else {
          // Small/Medium: ~square-ish grid, adjusted for aspect ratio
          cols = preset;
          rows = Math.round(preset * (rect.height / rect.width));
          rows = clamp(rows, Math.max(8, preset-3), preset+3);
        }

        grid.cols = cols;
        grid.rows = rows;

        grid.cell = Math.floor(Math.min(rect.width / grid.cols, rect.height / grid.rows));
        grid.w = grid.cols * grid.cell;
        grid.h = grid.rows * grid.cell;
        grid.offsetX = Math.floor((rect.width - grid.w) / 2);
        grid.offsetY = Math.floor((rect.height - grid.h) / 2);
      }

      function isOccupied(x,y){
        for (const s of snake) if (s.x===x && s.y===y) return true;
        for (const f of foods) if (f.x===x && f.y===y) return true;
        return false;
      }

      function updateHud(){
        timeText.textContent = formatTime(elapsedMs);
        lenText.textContent = String(snake.length);
        speedText.textContent = `${speed.toFixed(0)} /s`;
      }

      // ---------- Game setup ----------
      function resetSnake(){
        snake = [];
        const startX = Math.floor(grid.cols/2);
        const startY = Math.floor(grid.rows/2);
        for (let i=0;i<START_LEN;i++) snake.push({x:startX-i, y:startY});
        dir = {x:1,y:0};
        nextDir = {x:1,y:0};
      }

      function pickTargetAngle(){
        const pool = (gradeActive===6) ? G6 : G5;
        let picked = pool[randInt(0, pool.length)];
        let tries = 0;
        while (picked === prevTargetAngle && tries < 30){
          picked = pool[randInt(0, pool.length)];
          tries++;
        }
        prevTargetAngle = picked;
        return picked;
      }

      function pickTheme(){
        curTheme = FOOD_THEMES[randInt(0, FOOD_THEMES.length)];
        correctUsesA = Math.random() < 0.5; // randomize which color is correct each refresh
      }

      function placeFood(value,isCorrect){
        let x,y,tries=0;
        do{
          x = randInt(0, grid.cols);
          y = randInt(0, grid.rows);
          tries++;
          if (tries > 700) break;
        } while (isOccupied(x,y));

        const useA = isCorrect ? correctUsesA : !correctUsesA;
        foods.push({
          x,y,value,isCorrect,
          fill: useA ? curTheme.aFill : curTheme.bFill,
          stroke: useA ? curTheme.aStroke : curTheme.bStroke
        });
      }

      function spawnFoodsAndTarget(){
        foods = [];
        pickTheme();

        targetAngle = pickTargetAngle();

        const pool = (gradeActive===6) ? G6 : G5;
        const desiredCount = foodCountFromTime(elapsedMs);

        // build wrong list (unique, not target)
        const candidates = pool.filter(a => a !== targetAngle);
        shuffle(candidates);

        const wrongNeeded = Math.min(desiredCount - 1, candidates.length);
        const wrongAngles = candidates.slice(0, wrongNeeded);

        placeFood(targetAngle, true);
        for (const w of wrongAngles) placeFood(w, false);

        drawDial();
      }

      function applySpeedProfile(){
        const p = SPEED_PROFILES[speedActive] || SPEED_PROFILES.normal;
        speed = p.start;
        stepIntervalMs = 1000 / speed;
        lastRampBucket = 0;
      }

      function resetRunState(){
        correctCount = 0;
        wrongCount = 0;

        applySpeedProfile();

        resetSnake();
        spawnFoodsAndTarget();

        elapsedMs = 0;
        updateHud();
        draw();
      }

      // ---------- Splash ----------
      function showSplash(mode){
        onSplash = true;
        splash.classList.add('show');

        if (mode === "start"){
          dead = false;
          postGame.style.display = "none";
          rankPinned.style.display = "none";
          splashTitle.textContent = "Angle Snake";
          splashText.textContent =
            "Eat the food that matches the target angle in the circle (top-center). Correct = grow, wrong = shrink (but never below the start size).";
          enterPrompt.textContent = "Press Enter to start.";
        } else {
          rankPinned.style.display = "block";
          postGame.style.display = "block";
          splashTitle.textContent = "Game Over";
          splashText.textContent = "Press Enter to retry.";
          enterPrompt.textContent = "Press Enter to retry.";
        }
      }

      function hideSplash(){
        onSplash = false;
        splash.classList.remove('show');
      }

      // ---------- Start / End ----------
      function startGame(){
        gradeActive = gradePending;
        arenaActive = arenaPending;
        speedActive = speedPending;

        recomputeGrid(); // arena size affects grid
        running = true;
        dead = false;

        resetRunState();
        startTimeMs = performance.now();
        lastStepMs = performance.now();
        hideSplash();
      }

      function endGame(){
        running = false;
        dead = true;

        const timeSec = Math.floor(elapsedMs/1000);
        const len = snake.length;

        const base = (timeSec * 10) + (len * 50) + (correctCount * 200);
        const penaltyMultiplier = Math.max(0.30, 1 - (wrongCount * 0.05));
        const score = Math.max(0, Math.floor(base * penaltyMultiplier));

        const total = correctCount + wrongCount;
        const acc = total===0 ? 0 : Math.round((correctCount/total)*100);

        finalTime.textContent = formatTime(elapsedMs);
        finalLen.textContent = String(len);
        finalScore.textContent = String(score);
        finalAcc.textContent = `${acc}%`;

        const {rankName, rankIndex} = getRank(score);
        rankPinned.textContent = `Rank ${rankIndex}: ${rankName}`;

        showSplash("retry");
      }

      function getRank(score){
        const tiers = [
          { name:"GOAT",     min:13000 },
          { name:"Legend",   min:10800 },
          { name:"Elite",    min: 8800 },
          { name:"Champion", min: 7000 },
          { name:"Pro",      min: 5400 },
          { name:"Skilled",  min: 4000 },
          { name:"Contender",min: 2800 },
          { name:"Apprentice",min:1800 },
          { name:"Rookie",   min:  900 },
          { name:"Noob",     min:    0 },
        ];
        for (let i=0;i<tiers.length;i++){
          if (score >= tiers[i].min) return { rankName: tiers[i].name, rankIndex: i+1 };
        }
        return { rankName:"Noob", rankIndex:10 };
      }

      // ---------- Input ----------
      const keyMap = {
        ArrowUp:{x:0,y:-1}, ArrowDown:{x:0,y:1}, ArrowLeft:{x:-1,y:0}, ArrowRight:{x:1,y:0},
        w:{x:0,y:-1}, s:{x:0,y:1}, a:{x:-1,y:0}, d:{x:1,y:0},
        W:{x:0,y:-1}, S:{x:0,y:1}, A:{x:-1,y:0}, D:{x:1,y:0},
      };

      function trySetDir(v){
        if (v.x === -dir.x && v.y === -dir.y) return;
        nextDir = {x:v.x, y:v.y};
      }

      window.addEventListener('keydown', (e) => {
        if (onSplash && e.key === "Enter"){
          e.preventDefault();
          e.stopPropagation();
          if (document.activeElement && document.activeElement.tagName === "SELECT"){
            document.activeElement.blur();
          }
          startGame();
          return;
        }

        if (onSplash){
          const v = keyMap[e.key];
          if (v) trySetDir(v);
          return;
        }

        const v = keyMap[e.key];
        if (v){
          e.preventDefault();
          trySetDir(v);
        }
      }, {passive:false});

      gradeSelect.addEventListener('change', () => {
        gradePending = (Number(gradeSelect.value) === 6) ? 6 : 5;
      });
      arenaSelect.addEventListener('change', () => {
        arenaPending = arenaSelect.value;
      });
      speedSelect.addEventListener('change', () => {
        speedPending = speedSelect.value;
      });

      angleNumBtn.addEventListener('click', () => {
        showAngleNumber = !showAngleNumber;
        angleNumBtn.textContent = showAngleNumber ? "On" : "Off";
        angleNumBtn.classList.toggle('off', !showAngleNumber);
        drawDial();
      });

      // ---------- Mechanics ----------
      function rampSpeedIfNeeded(){
        const p = SPEED_PROFILES[speedActive] || SPEED_PROFILES.normal;
        const sec = Math.floor(elapsedMs/1000);
        const bucket = Math.floor(sec / p.every);
        if (bucket > lastRampBucket){
          lastRampBucket = bucket;
          speed = clamp(speed + p.step, p.start, p.cap);
          stepIntervalMs = 1000 / speed;
        }
      }

      function step(){
        dir = {...nextDir};

        const head = snake[0];
        const nx = head.x + dir.x;
        const ny = head.y + dir.y;

        // walls
        if (nx < 0 || nx >= grid.cols || ny < 0 || ny >= grid.rows){
          endGame(); return;
        }

        // self
        for (let i=0;i<snake.length;i++){
          if (snake[i].x===nx && snake[i].y===ny){
            endGame(); return;
          }
        }

        snake.unshift({x:nx,y:ny});

        // food
        let ate = null;
        for (const f of foods){
          if (f.x===nx && f.y===ny){ ate = f; break; }
        }

        if (ate){
          if (ate.isCorrect){
            correctCount++;
            // grow (keep tail)
          } else {
            wrongCount++;
            // shrink a bit, but never below start size
            if (snake.length>0) snake.pop();
            if (snake.length > MIN_LEN) snake.pop();
            while (snake.length < MIN_LEN){
              const t = snake[snake.length-1];
              snake.push({x:t.x, y:t.y});
            }
          }
          // refresh all foods + target together
          spawnFoodsAndTarget();
        } else {
          snake.pop();
        }
      }

      // ---------- Drawing ----------
      function roundRect(c,x,y,w,h,r){
        const rr = Math.min(r, w/2, h/2);
        c.beginPath();
        c.moveTo(x+rr,y);
        c.arcTo(x+w,y,x+w,y+h,rr);
        c.arcTo(x+w,y+h,x,y+h,rr);
        c.arcTo(x,y+h,x,y,rr);
        c.arcTo(x,y,x+w,y,rr);
        c.closePath();
      }

      function snakeColorAt(i){
        const mode = colorSelect.value;
        if (mode === 'rainbow'){
          const t = snake.length<=1 ? 0 : (i/(snake.length-1));
          const hue = (210 + t*280) % 360;
          return `hsl(${hue}, 90%, 62%)`;
        }
        const map = {
          red:'hsl(0, 90%, 62%)',
          orange:'hsl(28, 92%, 60%)',
          yellow:'hsl(55, 92%, 60%)',
          green:'hsl(140, 70%, 55%)',
          blue:'hsl(205, 95%, 62%)',
          indigo:'hsl(255, 80%, 65%)',
          violet:'hsl(285, 85%, 68%)',
          white:'hsl(0, 0%, 92%)',
        };
        return map[mode] || 'hsl(205, 95%, 62%)';
      }

      function drawGrid(){
        ctx.save();
        ctx.translate(grid.offsetX, grid.offsetY);
        ctx.strokeStyle = getComputedStyle(document.documentElement).getPropertyValue('--grid').trim() || 'rgba(255,255,255,.06)';
        ctx.lineWidth = 1;

        for (let c=0;c<=grid.cols;c++){
          const x = c*grid.cell + 0.5;
          ctx.beginPath(); ctx.moveTo(x,0); ctx.lineTo(x,grid.h); ctx.stroke();
        }
        for (let r=0;r<=grid.rows;r++){
          const y = r*grid.cell + 0.5;
          ctx.beginPath(); ctx.moveTo(0,y); ctx.lineTo(grid.w,y); ctx.stroke();
        }
        ctx.restore();
      }

      function drawFoods(){
        ctx.save();
        ctx.translate(grid.offsetX, grid.offsetY);

        for (const f of foods){
          const x = f.x * grid.cell;
          const y = f.y * grid.cell;

          ctx.fillStyle = f.fill;
          ctx.strokeStyle = f.stroke;
          ctx.lineWidth = 2;

          const pad = 3;
          roundRect(ctx, x+pad, y+pad, grid.cell-pad*2, grid.cell-pad*2, 10);
          ctx.fill(); ctx.stroke();

          ctx.fillStyle = 'rgba(255,255,255,.92)';
          ctx.font = '900 16px system-ui, -apple-system, Segoe UI, Roboto, Arial';
          ctx.textAlign = 'center';
          ctx.textBaseline = 'middle';
          ctx.fillText(String(f.value), x + grid.cell/2, y + grid.cell/2 + 0.5);
        }

        ctx.restore();
      }

      function drawSnake(){
        ctx.save();
        ctx.translate(grid.offsetX, grid.offsetY);

        const pad = 3;
        const r = 12;

        for (let i=snake.length-1;i>=0;i--){
          const s = snake[i];
          const x = s.x * grid.cell;
          const y = s.y * grid.cell;

          ctx.fillStyle = snakeColorAt(i);
          if (i===0){
            ctx.shadowColor = ctx.fillStyle;
            ctx.shadowBlur = 16;
          } else {
            ctx.shadowBlur = 0;
          }

          roundRect(ctx, x+pad, y+pad, grid.cell-pad*2, grid.cell-pad*2, r);
          ctx.fill();

          if (i===0){
            ctx.shadowBlur = 0;
            ctx.fillStyle = 'rgba(0,0,0,.35)';
            const cx = x + grid.cell/2;
            const cy = y + grid.cell/2;
            const ex = dir.x===1 ? 5 : dir.x===-1 ? -5 : 0;
            const ey = dir.y===1 ? 5 : dir.y===-1 ? -5 : 0;
            ctx.beginPath(); ctx.arc(cx-5+ex, cy-4+ey, 2.2, 0, Math.PI*2); ctx.fill();
            ctx.beginPath(); ctx.arc(cx+5+ex, cy-4+ey, 2.2, 0, Math.PI*2); ctx.fill();
          }
        }

        ctx.restore();
      }

      function draw(){
        const rect = canvas.getBoundingClientRect();
        ctx.clearRect(0,0,rect.width,rect.height);

        ctx.save();
        ctx.fillStyle = 'rgba(0,0,0,.10)';
        ctx.fillRect(0,0,rect.width,rect.height);
        ctx.restore();

        drawGrid();
        drawFoods();
        drawSnake();
      }

      function drawDial(){
        const rect = dialCanvas.getBoundingClientRect();
        const w = rect.width, h = rect.height;
        const cx = w/2, cy = h/2;
        const R = Math.min(w,h)*0.42;

        dctx.clearRect(0,0,w,h);

        dctx.save();
        dctx.lineWidth = 4;
        dctx.strokeStyle = 'rgba(255,255,255,.10)';
        dctx.beginPath();
        dctx.arc(cx,cy,R*1.06,0,Math.PI*2);
        dctx.stroke();

        const rad = (targetAngle % 360) * Math.PI/180;
        const theta = -rad;

        dctx.lineWidth = 5;
        dctx.strokeStyle = 'rgba(232,238,247,.92)';
        dctx.beginPath();
        dctx.moveTo(cx,cy);
        dctx.lineTo(cx + R, cy);
        dctx.stroke();

        dctx.strokeStyle = 'rgba(77,208,255,.95)';
        dctx.beginPath();
        dctx.moveTo(cx,cy);
        dctx.lineTo(cx + Math.cos(theta)*R, cy + Math.sin(theta)*R);
        dctx.stroke();

        const arcR = R*0.62;
        dctx.lineWidth = 7;
        dctx.strokeStyle = 'rgba(255,255,255,.82)';
        dctx.lineCap = 'round';

        if (targetAngle === 360){
          dctx.beginPath();
          dctx.arc(cx,cy,arcR,0,Math.PI*2);
          dctx.stroke();
        } else {
          dctx.beginPath();
          dctx.arc(cx,cy,arcR,0,theta,theta<0);
          dctx.stroke();
        }

        if (showAngleNumber){
          dctx.fillStyle = 'rgba(232,238,247,.95)';
          dctx.font = '950 22px system-ui, -apple-system, Segoe UI, Roboto, Arial';
          dctx.textAlign = 'center';
          dctx.textBaseline = 'middle';
          dctx.fillText(`${targetAngle}°`, cx, cy + R*0.83);
        }

        dctx.restore();
      }

      // ---------- Main loop ----------
      function tick(now){
        if (running && !dead){
          elapsedMs = now - startTimeMs;
          rampSpeedIfNeeded();

          // if we crossed a food-count threshold, refresh at next eat (simple),
          // OR we can proactively refresh right when threshold is reached:
          // We'll do a light proactive refresh ONCE when the count increases.
          const desired = foodCountFromTime(elapsedMs);
          if (foods.length !== desired){
            // refresh everything so the player sees the new difficulty immediately
            spawnFoodsAndTarget();
          }

          if (now - lastStepMs >= stepIntervalMs){
            lastStepMs = now;
            step();
          }
          updateHud();
        }
        draw();
        requestAnimationFrame(tick);
      }

      // ---------- Init ----------
      function init(){
        // UI defaults
        showAngleNumber = false;
        angleNumBtn.textContent = "Off";
        angleNumBtn.classList.add('off');

        gradePending = (Number(gradeSelect.value) === 6) ? 6 : 5;
        arenaPending = arenaSelect.value;
        speedPending = speedSelect.value;

        resizeCanvases();

        // show a dial immediately on splash
        gradeActive = gradePending;
        arenaActive = arenaPending;
        speedActive = speedPending;
        recomputeGrid();
        resetSnake();
        spawnFoodsAndTarget();

        elapsedMs = 0;
        applySpeedProfile();
        updateHud();
        draw();

        showSplash("start");

        window.addEventListener('resize', () => {
          resizeCanvases();
          recomputeGrid();
          draw();
          drawDial();
        });

        requestAnimationFrame(tick);
      }

      init();
    })();
  </script>
</body>
</html>


